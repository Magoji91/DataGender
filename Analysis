#Import Data
data <- read.csv("C:/Users/smsanda/Downloads/data.csv", header=FALSE, sep=";")
View(data)


head(data) # Print the first few, or last few, lines of a mdm object
str(data) #check the variables / Get a summary of an object’s structure
summary(data) #Get more detailed information out a model.
dim(data) #check dimesions ( number of row & columns) in data set
ls(data) # List all variables in the environment.
table(is.na(data)) # See counts of missing values
colSums(is.na(data)) # missing value in data exploration stages.
unique(data) #See unique values.

#Subsetting data
# Select only the variables that you are interested in.

install.packages("dplyr")
library(dplyr)

#filter: the first argument is the data frame; the second argument is the condition by which we want it subsetted. The result is the entire data frame with only the rows we wanted.
#select: the first argument is the data frame; the second argument is the names of the columns we want selected from it. We don’t have to use the names() function, and we don’t even have to use quotation marks. We simply list the column names as objects.

colint <-select(filter(data, V3 == 1, V2 == 1),c(V17, V18, V19, V20, V21, V22))



#Transforming raw variables
Well that certainly removes a lot of rows, we went from 918 to 317 participants! Now that we have filtered
out all unwanted participants, we can look at restructuring our data so that we can test our hypothesis. The
questions for the math test were multiple choice questions with 5 answer options, as such all answers are
coded in numbers 1:5, but we are actually only interested in whether a question was answered correctly or
not. We need to recode all answers to either 0 (incorrect) or 1 (correct). We can do this using a simple for
loop!


#Transforming raw variables
# First we create a list with the correct answer options to each question, so we can iterate through it in our for loop.
ans <- list(V17 = 3, V18 = 3, V19 = 1, V20 = 2, V21 = 1, V22 = 4)

# Now we iterate through our all of the math questions and recode them. If the answer is correct, we code it as a 1, otherwise it's a 0.
for (i in names(ans)){
for (j in 1:nrow(colint)){
if (colint[, i][j] == ans[i]){
if (is.null(x) || x == '') {
colint[, i][j] <- 1
} else {
colint[, i][j] <- 0
}
}
}

# Let's inspect our data to see if it worked
head(colint[, which(names(colint) == 'V17'):which(names(colint) == 'V22')])

Looks like that worked! Now we have to get a sum score on the math test for each participant, so we can
compare the performance on the math test between groups. We can do this using the which() function like
we did in the previous block of code to find out which columns we are interested in. After that we use the
rowSums() function to get a sumscore for every participant, which we will store in our dataST under the
$sumscore variable.

colint$sumscore <- rowSums(colint[, which(names(colint) == 'math1'):which(names(colint) == 'math8')])

# Let's create a histogram to inspect our freshly created sumscore variable!

hist(colint$sumscore)

# Get some more descriptive statistics for the sumscore variables
summary(colint$sumscore)

sd(colint$sumscore)


Assigning groups
Now that we have the sumscores for each participant we will assign each participant to a group, so that we
can compare the two groups! All participants in the control group skipped the $ST.threat question, so they
will have a value of NA there. Hence, everyone who has a value of NA on the $ST.threat question should
receive a $condition value of 0, and everyone else should get a value of 1.

# First we will set every participants condition to 1, after that we will change all participants that are in the control condition to a 0.
colint$condition <- 1
# Now let's set the control participants to 0.

for (i in 1:nrow(dataST)){
if (is.na(colint$ST.threat[i])){
colint$condition[i] <- 0
}
}
table(colint$condition)

Running the analysis
Looks like our participants are almost 50/50 divided over conditions (as we would expect!). Now that we
have done all our data manipulation, it’s time to do an analysis! In this example we only look at the t-test
itself, but in your final submission you should also include assumption checks.

t.test(colint$sumscore ~ colint$condition)



























































































stereo1 <- data[c(10:21),c(2,6:7)]

#To create the new data frame ‘stereo,’ we subsetted the ‘edata data frame by extracting rows 10-21, and columns 2, 6, and 7. Pretty simple, right?

#Another way to subset the data frame with brackets is by omitting row and column references. Take a look at this code:
stereo2 <- data[-c(1:9,22:50),-c(1,3:5)]

#Here, instead of subsetting the rows and columns we wanted returned, we subsetted the rows and columns we did not want returned and then omitted them with the “-” sign. If we now call stereo1 and stereo2, we can see that both data frames return the same subset of the original education data frame.





